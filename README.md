3장. 스칼라 두 번째 걸음
==================
<p>
콘즈 연산자 (::)<br>
&nbsp;ㄴ 콘즈 연산자의 호출 대상 객체는 콜론(:) 바로 뒤의 객체이다.<br>
</p>

<p>
리스트 뒤에 원소를 추가하는 효율적인 방법<br>
&nbsp;ㄴ 리스트를 뒤집는다 (reverse) -> 콘즈 연산자로 맨 앞에 요소 추가 -> 다시 뒤집는다.<br>
&nbsp;ㄴ 이렇게 하는 이유: 리스트 뒤에 원소를 추가하는 연산은 리스트의 길이에 비례한 시간이 걸리기 때문, 반면 콘즈 연산자는 상수 시간이 걸린다.<br>
</p>

<p>
튜플<br>
&nbsp;ㄴ 각기 다른 타입의 원소를 담을 수 있는 컬렉션<br>
&nbsp;ㄴ 튜플에는 동시에 문자열과 정수를 함께 넣을 수 있다.<br>
&nbsp;ㄴ 단, 튜플의 원소를 리스트의 원소와 같이 접근할 수 는 없다.<br>
&nbsp;ㄴ 반드시 ._N 으로 접근 (또 N은 0이 아니라 1부터 시작)<br>
</p>

<p>
집합과 맵<br>
</p>

<p>
함수형으로 한 걸음 더 나아가는 방법은 var를 사용하지 않고 프로그램하려 노력하는 것이다.<br/>
스칼라는 val을 더 많이 사용하도록 권한다.<br/>
<p>

<p>
스칼라 프로그래머의 균현 잡힌 태도<br/>
val, 변경 불가능한 객체, 부수 효과가 없는 메소드를 더 많이 사용하라. 먼저 그런 접근 방법을 먼저 시도해보라. var나 변경 가능 객체나 부수 효과가 있는 메소드를 사용해야 할 구체적인 필요성이 있고 그런 이유를 정당화할 수 있는 경우에만 var, 변경 가능성, 부수 효과를 활용하라.<br/>
</p>


4장. 클래스와 객체
==================
<p>
클래스 (class)<br/>
&nbsp;ㄴ 스칼라의 기본 접근 수준은 전체 공개다.<br/>
&nbsp;ㄴ 메소드 파라미터는 항상 val 이다. (재할당 시 Compile error)<br/>
&nbsp;ㄴ 메소드 마지막에는 명시적으로 return을 사용하지 않아도 맨 나중에 계산한 값을 반환한다.<br/>
&nbsp;ㄴ 메소드 작성 시 권한하는 스타일은 return을 명시적으로 사용하지 않는 것, 특히 여러 번 사용하지 않는 것이다. 대신 각 메소드가 한 값을 계산하는 표현식인 것 처럼 생각하라. 이렇게 계산한 값이 바로 메소드의 반환 값이다. 이런 철학을 가지고 코딩하면, 메소드를 아주 작게 유지하고 커다란 메소드를 더 작은 여러 메소드로 나누게 된다. 다만 환경에 따라 다르므로 명시적으로 return을 사용할 수 는 있다.<br/>
&nbsp;ㄴ 스칼라 클래스에는 정적(static) 멤버가 없다. 대신 싱글톤 객체를 제공한다.<br/>
</p>

<p>
싱글톤 객체 (object)<br/>
&nbsp;ㄴ 어떤 싱글톤 객체의 이름이 어떤 클래스와 같을 때, 그 객체를 클래스의 동반 객체(companion object)라고 한다. 다만, 클래스와 동반 객체는 반드시 같은 소스 파일 안에 정의해야 한다. 이때 역으로 해당 클래스를 싱글톤 객체의 동반 클래스(companion class)라 부른다. 클래스와 동반 객체는 상대방의 비공개 멤버에 접근할 수 있다.<br/>
&nbsp;ㄴ 자바 프로그래머라면 싱글톤을 자바의 정적 메소드를 담아두는 집처럼 생각하는 것도 한 가지 방법이다. 싱글톤 객체의 메소드도 정적 메소드와 비슷한 방식으로 호출할 수 있다.<br/>
&nbsp;ㄴ 싱글톤 객체 정의는 타입을 정의하지 않는다. 따라서 싱글톤 객체 정의만 있다면 해당 타입의 객체를 만들 수 없다. (싱글톤은 new로 인스턴스화 할 수 없다.) 이 때는 동반 클래스를 정의해야만 해당 타입의 객체를 만들 수 있다.<br/>
&nbsp;ㄴ 클래스와 싱글톤 객체의 한 가지 차이는 싱글톤 객체는 파라미터를 받을 수 없고 클래스는 받을 수 있다는 점이다. 싱글톤은 new로 인스턴스화할 수 없기 때문에 파라미터를 싱글톤에 넘길 방법이 없다.<br/>
&nbsp;ㄴ 컴파일러는 각 싱글톤 객체를 합성한 클래스(synthetic class)의 인스턴스로 구현하고, 이를 정적 변수가 참조한다.<br/>
&nbsp;ㄴ 동반 클래스가 없는 싱글톤 객체를 독립 개체라고도 한다.<br/>
&nbsp;ㄴ 독립 객체의 활용법은 필요한 도구 메소드를 한데 모아두거나(java의 util 클래스), 스칼라 애플리케이션의 진입점을 만들 때 사용할 수 있다.<br/>
&nbsp;ㄴ 자바에서는 public class를 그 클래스 이름과 같은 이름의 파일에 저장해야 하지만, 스칼라에서는 원하는 대로 .scala로 끝나는 파일 이름을 정할 수 있다는 점이다. 그 파일 안에는 마음대로 아무 클래스나 코드를 넣을 수 있다. 하지만 스크립트가 아닌 경우 자바와 마찬가지로 파일에 들어갈 클래스 이름을 따라 파일 이름을 짓는 것을 권장한다.<br/>
&nbsp;ㄴ .scala 파일 안에 정의만 들어있는 것은 스크립트가 아니다. 스크립트는 결과를 계산하는 표현식이 끝에 와야만 한다. 114쪽 참조<br/>
</p>

<p>
참고<br/>
&nbsp;ㄴ 스칼라는 항상 java.lang과 scala 패키지의 멤버를 암시적으로 임포트한다. 또한 scala 패키지에 있는 Predef라는 싱글톤 객체의 멤버도 항상 임포트 한다. Predef에는 유용한 메소드가 많이 있으며, println도 실제로는 Predef의 println을 호출하는 것이다. (Predef.println은 다시 Console.println을 호출하고, 그 메소드가 실제 출력을 수행한다.) assert를 사용할 때도 역시 Predef.assert를 사용하는 것이다.<br/>
&nbsp;ㄴ fsc (fast scala compiler)<br/>
</p>

5장. 기본 타입과 연산
====================
<p>
Int<br/>
&nbsp;ㄴ 16진수: 0x로 시작할 경우<br/>
&nbsp;ㄴ 8진수: 0 으로 시작할 경우<br/>
&nbsp;ㄴ 10진수: 0이 아닌 숫자로 시작하고 그 밖의 추가 장식이 없을 경우<br/>
</p>

<p>
Long<br/>
&nbsp;ㄴ 정수 리터럴이 L이나 l로 끝나면 Long<br/>
&nbsp;ㄴ 끝에 아무것도 없으면 Int 이다.<br/>
</p>

<p>
Double, Float<br/>
&nbsp;ㄴ 부동소수점 리터럴이 F나 f로 끝나면 그 수는 Float 타입<br/>
&nbsp;ㄴ 그렇지 않는 부동소수점 리터럴은 Double<br/>
</p>

<p>
Char<br/>
&nbsp;ㄴ 작은 따옴표 안에 유니코드 문자를 넣은 문자 리터럴을 지칭<br/>
</p>

<p>
심볼 리터럴<br/>
</p>

<p>
연산자<br/>
&nbsp;ㄴ 리터럴 비교 뿐만 아니라 객체 및 객체 필드 값 비교까지 가능<br/>
&nbsp;ㄴ 자동으로 null을 체크하기 때문에 직접 null을 검사할 필요가 없다.<br/>
</p>


6장. 함수형 객체
====================
<p>
여기서는 좀 더 완전한 기능을 갖춘 스칼라 클래스 작성법을 알아본다.<br/>
변경 가능한 상태를 전혀 갖지 않는 함수형 객체 (functional object)을 다룬다.<br/>
</p>

<p>
변경 불가 분수 클래스(Rational)을 만들어보자<br/>
</p>

<p>
class Rational(n: Int, d: Int)<br/>
</p>

<p>
클래스 이름인 Rational 뒤에 괄호가 오고, 그 안에 n과 d라는 식별자가 있다.<br/>
이를 클래스 파라미터 라고 부른다. 스칼라 컴파일러는 내부적으로 두 클래스 파라미터를 종합해서, 클래스 파라미터와 같은 두 인자를 받는 주 생성자 (primary constructor)를 만든다.<br/>
</p>


<p>
class Rational(n: Int, d: Int) {<br/>
&#09 println(“Created “ + n + “/“ + d)<br/>
}<br/>
</p>

<p>
스칼라 컴파일러는 println을 호출하는 위 코드를 Rational 클래스의 주 생성자(primary constructor)에 넣는다.<br/>
n과 d가 클래스 내부에서 쓰이긴 했지만 생성자 내부에서만 쓰이는 경우 스칼라 컴파일러는 그들에 해당하는 필드를 생성하지 않는다.<br/>
주 생성자(primary constructor)는 클래스의 유일한 진입점이다.<br/>
</p>

<p>
override<br/>
&nbsp;ㄴ 8장에서 다시 언급<br/>
</p>

<p>
require<br/>
&nbsp;ㄴ 전제 조건을 만들 때 사용<br/>
&nbsp;ㄴ require 메소드는 인자로 불리언 값을 하나 받는다. 이 값이 참(true)이면 require 문이 정상적으로 끝나고 다음으로 진행, 아니라면 IllegalArgumentException 발생<br/>
</p>

<p>
필드 추가<br/>
</p>

<p>
자기 참조<br/>
</p>

<p>
보조 생성자<br/>
&nbsp;ㄴ 하나의 클래스에 여러 생성자가 필요한 경우 보조 생성자를 사용하자!<br/>
&nbsp;ㄴ 스칼라에서는 주 생성자가 아닌 다른 생성자는 보조 생성자(auxiliary constructor)라고 부른다.<br/>
&nbsp;ㄴ 스칼라에서 보조 생성자는 def this(...)로 시작한다.<br/>
&nbsp;ㄴ 스칼라에서 모든 보조 생성자는 반드시 같은 클래스에 속한 다른 생성자를 호출하는 코드로 시작해야 한다. (모든 보조 생성자의 첫 구문은 this(...)여야 한다.)<br/>
</p>

<p>
비공개 필드와 메소드<br/>
</p>

<p>
연산자 정의<br/>
&nbsp;ㄴ 스칼라에서는 연산자도 메소드<br/>
&nbsp;ㄴ 그러므로 클래스의 멤버로 연산자 메소드 추가가 가능<br/>
</p>

<p>
스칼라의 식별자<br/>
</p>

<p>
메소드 오버로드<br/>
&nbsp;ㄴ 이 부분은 java와 비슷한 것 같다.<br/>
</p>

<p>
암시적 타입 변환<br/>
&nbsp;ㄴ implicit def intoRational(x: Int) = new Rational(x)<br/>
&nbsp;ㄴ 가능하면 21장에서 다루는 다른 암시 기법을 활용하는 것이 좋다.<br/>
</p>


7장. 내장 제어 구문
===================
- 스칼라가 제공하는 내장 제어구문: if, while, for, try, match, function call
- 스칼라의 제어 구문 수가 적은 이유는 설계 초기 함수 리터럴을 포함했기 때문, 제어 구문 위에 다른 제어 구문을 하나하나 추가하기 보다는, 라이브러리에 제어 구문을 추가하는 편을 택함
- 스칼라의 제어구문은 대부분 어떤 값을 결과로 내놓는다. 이는 프로그램 전체를 값을 계산하는 관점에서 바라보고, 프로그램 구성요소 또한 값을 도출해야 한다는 함수 언어적 접근을 채용한 결과다.
- java와 스칼라의 차이점은 for, try, match가 값을 반환한다는 것에 있다. 스칼라는 제어구문들이 결과 값을 반환하기 때문에 임시변수가 필요 없다. 임시 변수를 만들어 계산한 값을 저장하는 과정이 없어지기 때문에 여러 가지 버그를 방지해준다. (Wow!!)

<p>
if 표현식<br/>
&nbsp;ㄴ 스칼라의 if는 다른 여러 언어와 마찬가지로 동<br/>
&nbsp;ㄴ if 표현식은 값을 내놓기 때문에 임시 변수를 없앨 수 있다. (java 에서도 리터럴을 그냥 바로 리턴하면 동일한거 아닌가?)<br/>
</p>

<p>
var filename = "default.txt"<br/>
if (!args.isEmpty)<br/>
&#09 filename = args(0)<br/>
</p>

<p>
val filename = if (!args.isEmpty) args(0) else "default.txt"<br/>
</p>

<p>
여기서 중요한 것은 filename을 var가 아닌 val로 선언했다는 것이다. (함수적 스타일)<br>
val을 사용함으로서 그 변수의 값이 결코 바뀌지 않음을 알려주고, 해당 변수의 값이 바뀌었는지를 찾아보기 위해 코드에서 그 변수의 모든 스코프를 다 뒤지는 일이 없게 해준다! (Wow!! @.@)<br>
</p>

<p>
while 루프<br>
&nbsp;ㄴ 여타 언어와 마찬가지로 동작<br>
&nbsp;ㄴ condition이 참인 동안 본문을 반복 수행<br>
&nbsp;ㄴ while과 do-while이 이루는 구조는 수행 결과가 특정 값을 반환하는 것이 아니기 때문에 표현식이라 하지 않고 '루프'라 부른다.<br>
&nbsp;ㄴ 루프의 결과는 타입이 Unit 이다.<br>
&nbsp;ㄴ 일반적으로, while 루프는 var 변수와 마찬가지로 최대한 이를 적게 사용하기 위해 노력할 것을 권장한다. (p.166)<br>
</p>

<p>
Unit 타입<br>
&nbsp;ㄴ 유니트 값(unit value) 밖에 없고, 이 값은 빈 괄호로 표기한다.<br>
&nbsp;ㄴ ()라는 값이 존재한다는 점에서 자바의 void와 스칼라의 Unit는 다르다.<br>
&nbsp;ㄴ println("hi") == () // true<br>
</p>
 
<p>
for 표현식<br>
&nbsp;ㄴ 스칼라의 for 표현식은 반복 처리를 위한 스위스 군용 만능 칼이라 할 수 있다. (맥가이버 칼이라고 쓰면 뭐라 할까봐 이렇게 표현한건가...-_-)<br>
</p>

<p>
val files = (new java.io.File(".")).listFiles<br>
for (file <- files)<br>
&#09 println(file)<br>
</p>

<p>
for (i <- 1 to 4)<br>
&#09 println(i)<br>
// 1, 2, 3, 4<br>
</p>

<p>
for (i <- 1 until 4)<br>
&#09 println(i)<br>
// 1, 2, 3<br>
</p>

<p>
이와 같이 스칼라에서는 간단하게 컬렉션을 직접 순회할 수 있다.<br/>
컬렉션을 직접 순회하면 코드도 더욱 짧아지고 배열을 순회하면서 인덱스를 잘못 처리해 발생할 수 있는 실수를 피할 수 있다.<br/>
인덱스를 0에서 시작할지, 1에서 시작할지, +1을 더할지, -1을 더할지, 마지막 순회에서 특별한 처리는 안해도 되는지 이런 질문을 아예 피할 수 있어 안전한 코드를 작성할 수 있다.<br/>
(와....대박 ㅜㅜ 근데 순서대로 순회한다는 보장은 있겠지? javascript의 for in 구문처럼 뒤통수 칠 일은 없어야 할텐데...)<br>
</p>

<p>
필터링 (ㅜㅜ)<br/>
&nbsp;ㄴ for 표현식을 통해 컬렉션 순회 시 전체 컬렉션에서 일부만 사용하고 싶은 경우 사용<br/>
&nbsp;ㄴ for 표현식에 필터(fileter)를 추가하면 가능하다.<br/>
&nbsp;ㄴ 혹시 필터를 메소드로 뺄 수는 없을까? 조건이 많아지면 필터가 복잡해질 것 같은데...<br/>
</p>

<p>
val files = (new java.io.File(".")).listFiles<br/>
for (file <- files if file.getName.endsWith(".scala"))<br/>
&#09;println(file)<br/>
같은 목적의 코드<br/>
for (file <- files) {<br/>
&#09;if (file.getName.endsWith(".scala"))<br/>
&#09;&#09;println(file)<br/>
}<br/>
</p>

<p>
여러 개의 필터 적용<br/>
for(<br/>
&#09;file <- files<br/>
&#09;if file.isFile<br/>
&#09;if file.getName.endsWith(".scala")<br/>
) println(file)<br/>
</p>

<p>
중첩 순회<br/>
&nbsp;ㄴ 여러 개의 제네레이터절을 추가하면 중첩 루프를 작성할 수 있다.<br/>
&nbsp;ㄴ 원한다면 괄호 대신 중괄호를 사용해 제네레이터와 필터를 감쌀 수 있다.<br/>
</p>

<p>
for 중에 변수 바인딩하기<br/>
&nbsp;ㄴ 필터링 부분에 변수를 선언할 수도 있다. (이 때 변수 선언은 val이나 var를 생략해도 된다.)<br/>
</p>

<p>
새로운 컬렉션 만들어내기 (for-yeild 표현식)<br/>
&nbsp;ㄴ for 표현식의 반복 결과를 저장하기 위한 값을 만들어 리턴하고자 할 때 사용<br/>
&nbsp;ㄴ for 표현식의 본문 앞에 yield라는 키워드를 사용하면 된다.<br/>
</p>